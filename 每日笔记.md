roslaunch cartographer_ros lidar.launch

[ERROR] [1519539033.564366334]: filter time older than odom message buffer
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```

laser_scan_matcher，首先尝试一下两帧激光匹配,当时我把 processScan函数重构了一下, 现在想想完全没必要．把imu和odom都关掉后,只凭scan就能两帧激光匹配,可以使用这个包作为初始化位姿,代替里程计不准的情况,时间长了会有累计误差,后期用amcl定位,加其他传感器.
*******
技巧：
```cpp
  std::string tf_error;
  // we need to make sure that the transform between the robot base frame and the global frame is available
  while (ros::ok()
      && !tf_.waitForTransform(global_frame_, robot_base_frame_, ros::Time(), ros::Duration(0.1), ros::Duration(0.01),
                               &tf_error))
  {
    ros::spinOnce();
    if (last_error + ros::Duration(5.0) < ros::Time::now())
    {
      ROS_WARN("Timed out waiting for transform from %s to %s to become available before running costmap, tf error: %s",
               robot_base_frame_.c_str(), global_frame_.c_str(), tf_error.c_str());
      last_error = ros::Time::now();
    }
    // The error string will accumulate and errors will typically be the same, so the last
    // will do for the warning above. Reset the string here to avoid accumulation.
    tf_error.clear();
  }
```
检查全局和局部代价地图所用的参数
**********
雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。

目标函数如下，寻找最佳位姿p
![公式.png](https://i.loli.net/2020/05/25/BUztfKQFXalj4WI.png)
函数m(x,y)代表地图空闲或不空闲的，位姿p包含位置(x,y)及朝向p_theta，r_theta代表雷达不同角度的射线，函数delta表示从地图中获取当前位姿p下的地图数值。

直接求偏导什么的，计算量太大，不切实际。接下来我们将用粒子滤波算法，求解上述目标函数。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
*********
`PointAccumulator`定义在smmap.h

for循环显然可以用OpenMP进行并行化,github上有OpenMP优化的gmapping
********
默认`depthimage_to_laserscan`转化的数据实际上还是只能检测到平行kinect的障碍物，而较低的障碍物或者较高的障碍物检测不到。ranges[]数组体现了横向每个障碍点到kinect距离。但是实际，纵向扫描的高度极为苛刻。



比如，在距离kinect不到1米处，放一个较低的障碍，图像如下：


经过转换，结果没看到低障碍的scan结果

算法的核心函数是`DepthImageToLaserScan.h`中的`convert`。现实世界的实际距离是通过深度图像转化的，而scan_hight是针对深度图像扫描高度。



这时候，节点的动态参数调整机制就发挥作用了，`rosrun rqt_reconfigure rqt_reconfigure`启动，然后调整`scan_height`

发现调到180左右就能扫描到0.8米处的低障碍，但是其他部分的scan会有变化.再大于180，低障碍一直能扫描到，但远处障碍的扫描结果又会变化，很难找到我们需要的`scan_heigth`.因为`scan_hight`对扫面的高度影响极小，但对远处的障碍物影响很大，何况kinect还有明显的噪声。


参考：
[深度图转激光原理](https://www.cnblogs.com/cv-pr/p/5725831.html)
[1个kinect生成3个scan](https://answers.ros.org/question/187694/depthimage_to_laserscan-choose-which-part-of-the-image-is-scanned/)