cur: -1.71000003815

roslaunch cartographer_ros lidar.launch

[ERROR] [1519539033.564366334]: filter time older than odom message buffer
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```

laser_scan_matcher，首先尝试一下两帧激光匹配,当时我把 processScan函数重构了一下, 现在想想完全没必要．把imu和odom都关掉后,只凭scan就能两帧激光匹配,可以使用这个包作为初始化位姿,代替里程计不准的情况,时间长了会有累计误差,后期用amcl定位,加其他传感器.
*******
技巧：
```cpp
  std::string tf_error;
  // we need to make sure that the transform between the robot base frame and the global frame is available
  while (ros::ok()
      && !tf_.waitForTransform(global_frame_, robot_base_frame_, ros::Time(), ros::Duration(0.1), ros::Duration(0.01),
                               &tf_error))
  {
    ros::spinOnce();
    if (last_error + ros::Duration(5.0) < ros::Time::now())
    {
      ROS_WARN("Timed out waiting for transform from %s to %s to become available before running costmap, tf error: %s",
               robot_base_frame_.c_str(), global_frame_.c_str(), tf_error.c_str());
      last_error = ros::Time::now();
    }
    // The error string will accumulate and errors will typically be the same, so the last
    // will do for the warning above. Reset the string here to avoid accumulation.
    tf_error.clear();
  }
```
检查全局和局部代价地图所用的参数
**********
雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。

目标函数如下，寻找最佳位姿p
![公式.png](https://i.loli.net/2020/05/25/BUztfKQFXalj4WI.png)
函数m(x,y)代表地图空闲或不空闲的，位姿p包含位置(x,y)及朝向p_theta，r_theta代表雷达不同角度的射线，函数delta表示从地图中获取当前位姿p下的地图数值。

直接求偏导什么的，计算量太大，不切实际。接下来我们将用粒子滤波算法，求解上述目标函数。
***********
xiaoqiang经常编译没有变化，可以`catkin_make clean`，再编译即可。
**********
laser_filters的使用

修改`range_filter.yaml`如下：
```sh
scan_filter_chain:
- name: box_filter
  type: laser_filters/LaserScanRangeFilter
  params:
    # use_message_range_limits: false   # if not specified defaults to false
    lower_threshold: 0.18  # 默认0
    upper_threshold: 0.22  # 默认100000.0
    lower_replacement_value: 0    # 默认 NaN
    upper_replacement_value: 999  # 默认 NaN
```
然后加载参数：`rosparam load range_filter.yaml scan_to_scan_filter_chain`

运行launch: `roslaunch laser_filters range_filter_example.launch`,里面就是节点`filter chain`和yaml文件


参考：[](https://blog.csdn.net/asdli/article/details/91128367)
************
激光雷达(Lidar)传感器的误差源

发送和接收激光束的精确耗时误差，也就是计时设备的精度问题

激光束的朝向误差。受限于激光雷达朝向测量设备的测量精度

目标材质的反射值特性，比如全黑的材料吸收了光的大部分能量，使得反射量极低；或者像镜子一样的材料会将大部分光反射到其它地方

运动形变(Motion Distortion)。由于激光雷达在跟随自动驾驶车辆前进的同时，对周围环境进行扫描建模，也就是说车辆相对于周围的环境是运动的，导致对环境测量的实际位置与真实位置存在偏差。
**********
LOAM不能用于2D雷达
激光雷达不能用于非常混乱的环境

机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。