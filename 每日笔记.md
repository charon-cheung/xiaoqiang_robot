roslaunch cartographer_ros lidar.launch
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
*******
检查全局和局部代价地图所用的参数

雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
**********
八叉树地图特点
- 稀疏: 不需要对空间进行稠密切分
- 结构化: 方块排列固定,切分为八份
- 非直接索引查询

点云地图: 无序,因为它的点都是无序的,无法坐标索引查询;
*********
金坛河滨小学 0519－82837968

imu的偏航角在长时间移动后会有严重的漂移误差，只能定时校准


节点`cartographer_node`的信息如下：
```sh
Publications:
 * /constraint_list [visualization_msgs/MarkerArray]
 * /landmark_poses_list [visualization_msgs/MarkerArray]
 * /rosout [rosgraph_msgs/Log]
 * /scan_matched_points2 [sensor_msgs/PointCloud2]
 * /submap_list [cartographer_ros_msgs/SubmapList]
 * /tf [tf2_msgs/TFMessage]
 * /trajectory_node_list [visualization_msgs/MarkerArray]

Subscriptions:
 * /scan [sensor_msgs/LaserScan]
 * /tf [tf2_msgs/TFMessage]
 * /tf_static [tf2_msgs/TFMessage]

Services:
 * /cartographer_node/get_loggers
 * /cartographer_node/set_logger_level
 * /finish_trajectory
 * /start_trajectory
 * /submap_query
```

节点`cartographer_occupancy_grid_node`：
```sh
Publications:
 * /map [nav_msgs/OccupancyGrid]
 * /rosout [rosgraph_msgs/Log]

Subscriptions:
 * /submap_list [cartographer_ros_msgs/SubmapList]
```


```sh
sudo apt-key adv --keyserver keys.gnupg.net --recv-key C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C8B3A55A6F3EFCDE

# Add the server to the list of repositories
sudo add-apt-repository "deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main" -u

# Install the libraries
sudo apt install librealsense2-dkms librealsense2-utils
```


如果RealSense使用USB2, Output Resolution自动降到`480*270 30fbs`，而非产品所宣称的1280 x 720 active stereo depth resolution和90fps；且只有Stereo Moudle在工作，无Image Sensor的RGB Moudle菜单项，无法进行3D建模。

编译安装完`librealsense`之后,可以直接输入`realsense-viewer`打开图像查看工具. 我开始插入的是USB2,所以出现各种报警,先忽略.


`roslaunch realsense2_camera rs_camera.launch`运行realsense的三种图像,但是没看到深度图


使用对齐的深度话题信息发布RGBD点云
```sh
roslaunch realsense2_camera rs_rgbd.launch
```
这一步还没有成功,在rviz里没看到结果,应该还是跟深度图不正常有关
**********





JUC-141 夫の前で調教して下さい 翔田千里
JUL-018 中文字幕 生意気な年下社長を更生させるインテリ淫語ガーター秘書
HODV-20714 夢共演 美熟女レズ！乱交！淫ら絶頂！
JUC-184 中文字幕 濡れ嫁・羞恥介護
JUC-483 3D美熟女共演！ 叔母の誘惑と母の愛情 紫彩乃 牧原れい子