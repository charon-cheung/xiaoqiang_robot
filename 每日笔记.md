roslaunch cartographer_ros lidar.launch

[ERROR] [1519539033.564366334]: filter time older than odom message buffer
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```

laser_scan_matcher，首先尝试一下两帧激光匹配,当时我把 processScan函数重构了一下, 现在想想完全没必要．把imu和odom都关掉后,只凭scan就能两帧激光匹配,可以使用这个包作为初始化位姿,代替里程计不准的情况,时间长了会有累计误差,后期用amcl定位,加其他传感器.
*******
技巧：
```cpp
  std::string tf_error;
  // we need to make sure that the transform between the robot base frame and the global frame is available
  while (ros::ok()
      && !tf_.waitForTransform(global_frame_, robot_base_frame_, ros::Time(), ros::Duration(0.1), ros::Duration(0.01),
                               &tf_error))
  {
    ros::spinOnce();
    if (last_error + ros::Duration(5.0) < ros::Time::now())
    {
      ROS_WARN("Timed out waiting for transform from %s to %s to become available before running costmap, tf error: %s",
               robot_base_frame_.c_str(), global_frame_.c_str(), tf_error.c_str());
      last_error = ros::Time::now();
    }
    // The error string will accumulate and errors will typically be the same, so the last
    // will do for the warning above. Reset the string here to avoid accumulation.
    tf_error.clear();
  }
```
检查全局和局部代价地图所用的参数
**********
雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。

目标函数如下，寻找最佳位姿p
![公式.png](https://i.loli.net/2020/05/25/BUztfKQFXalj4WI.png)
函数m(x,y)代表地图空闲或不空闲的，位姿p包含位置(x,y)及朝向p_theta，r_theta代表雷达不同角度的射线，函数delta表示从地图中获取当前位姿p下的地图数值。

直接求偏导什么的，计算量太大，不切实际。接下来我们将用粒子滤波算法，求解上述目标函数。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
*********
`PointAccumulator`定义在smmap.h

for循环显然可以用OpenMP进行并行化,github上有OpenMP优化的gmapping
********

```cpp
ScanMatcher::ScanMatcher(): m_laserPose(0,0,0)
{
    line_angle = 0.0;

    //m_laserAngles=0;
    m_laserBeams=0;
    m_optRecursiveIterations=9;
    m_activeAreaComputed=false;

    // This  are the dafault settings for a grid map of 5 cm
    // 5cm解析度的默认参数 定义scan-match的时候 这些参数会默认成这样。
    // 这个参数是计算似然位姿的时候使用的 实际的gmapping中没有用到。
    m_llsamplerange=0.01;
    m_llsamplestep=0.01;
    m_lasamplerange=0.005;
    m_lasamplestep=0.005;

    //地图进行拓展的大小
    m_enlargeStep=10.;

    m_fullnessThreshold=0.1;

    //指示里程计和陀螺仪是否可靠
    //如果可靠的话，那么进行score计算的时候，就需要对离里程计数据比较远的位姿增加惩罚
    //对于我们的应用来说 陀螺仪在短期内还是很可靠的。
    m_angularOdometryReliability=0.;
    m_linearOdometryReliability=0.;

    //理论上的离激光点的空闲距离 也就是说沿着激光束方向离激光点这么远距离的栅格一定是空闲的。
    m_freeCellRatio=sqrt(2.);

    //跳过一帧激光数据的开始几束激光
    m_initialBeamsSkip=0;   
   m_linePoints = new IntPoint[20000];
}
```