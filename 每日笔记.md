roslaunch cartographer_ros lidar.launch
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
*******
检查全局和局部代价地图所用的参数

雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
**********
八叉树地图特点
- 稀疏: 不需要对空间进行稠密切分
- 结构化: 方块排列固定,切分为八份
- 非直接索引查询

点云地图: 无序,因为它的点都是无序的,无法坐标索引查询;
*********
金坛河滨小学 0519－82837968

imu的偏航角在长时间移动后会有严重的漂移误差，只能定时校准


节点`cartographer_node`的信息如下：
```sh
Publications:
 * /constraint_list [visualization_msgs/MarkerArray]
 * /landmark_poses_list [visualization_msgs/MarkerArray]
 * /rosout [rosgraph_msgs/Log]
 * /scan_matched_points2 [sensor_msgs/PointCloud2]
 * /submap_list [cartographer_ros_msgs/SubmapList]
 * /tf [tf2_msgs/TFMessage]
 * /trajectory_node_list [visualization_msgs/MarkerArray]

Subscriptions:
 * /scan [sensor_msgs/LaserScan]
 * /tf [tf2_msgs/TFMessage]
 * /tf_static [tf2_msgs/TFMessage]

Services:
 * /cartographer_node/get_loggers
 * /cartographer_node/set_logger_level
 * /finish_trajectory
 * /start_trajectory
 * /submap_query
```

节点`cartographer_occupancy_grid_node`：
```sh
Publications:
 * /map [nav_msgs/OccupancyGrid]
 * /rosout [rosgraph_msgs/Log]

Subscriptions:
 * /submap_list [cartographer_ros_msgs/SubmapList]
```
******
## throttle

relay a topic, 限制最大发布频率或者带宽。使用格式: `rosrun topic_tools throttle messages <intopic> <msgs_per_sec> [outtopic]`

messages是当前使用的是throttle的messages模式,限制发布频率. intopic是指你想要改变频率的那个topic, msgs_per_sec是指你想要它发布的频率，而outtopic是指改变发布频率后的topic的名称，可以省略，**如果省略则自动在原来topic的名字上后缀throttle**

另外还有bytes模式,用以限制带宽: `rosrun topic_tools throttle bytes <intopic> <bytes_per_sec> <window> [outtopic]`

例如，让雷达的带宽占用降至1KBps，则命令为：
```sh
rosrun topic_tools throttle bytes base_scan 1024 1.0
```

改变topic发布频率并不是说原来的topic就没了，或者直接在原来的topic上更改，而是更throttle把其更改后的topic发布出来，原来的topic仍然存在.

有三个参数,需要注意的是`~lazy`,如果它等于True的话，只有当你订阅到throttle发出来的消息，它才会工作，这显然是ros::publish函数的lazy模式了

最大的问题是<font color=orange size=5> 频率控制的精度低,我要求4Hz,实际却在3.6Hz左右</font>,所以实际要设置的大一些

## transform

订阅一个topic或topic field，并在应用给定的Python表达式后将传入的数据发布到另一个topic。它主要用于简单的消息转换，例如计算向量或四元数的范数，甚至将四元数转换为欧拉角。它可以处理任何消息类型。

`transform <input> <output_topic> <output_type> [<expression>] [--import <module> [<module> ...]]`

input：要订阅的传入topic（或topic field）。
output_topic:要发布的输出topic。
expression:转换输入消息的Python表达式，在变量m中给出。默认表达式是m，它将输入（可以是topic field）转发到output_topic。
import :要在表达式中导入和使用的Python模块的列表。默认导入numpy模块。

```sh
# 计算IMU给出的方向四元数的范数
rosrun topic_tools transform /imu/orientation /norm std_msgs/Float64 'numpy.linalg.norm([m.x, m.y, m.z, m.w])'
# 将方向四元数转换为Euler角度
rosrun topic_tools transform /imu/orientation /euler geometry_msgs/Vector3 'tf.transformations.euler_from_quaternion([m.x, m.y, m.z, m.w])' --import tf
```

mux: multiplex between multiple topics.

relay: republish data on one topic to another.

relay_field: allow to republish data in a different message type

drop: relay a topic, dropping X out of every Y message.

参考:[throttle Wiki](http://wiki.ros.org/topic_tools/throttle)
**********
使用Kalibr标定相机的内参和多个相机相对位置关系即外参，需要准备kalibr提供的标定板

## 标定板

[下载标定板](https://github.com/ethz-asl/kalibr/wiki/downloads)

我下载的是`Aprilgrid 6x6 0.5x0.5m`(unscaled)，自定义缩放40%打印，A4纸刚好能打印出来

原版的参数是:6X6 tags，6乘6个格子，一个大格子size=5.5cm，一个小格子spacing=1.65cm

40%的缩放:6X6 tags，一个大格子size=2.2cm，一个小格子spacing=0.66cm。记得打印出来用尺子量一下，以免出现差错。
![标定板参数示意图](https://i.loli.net/2020/06/30/U68mzoAjeQEPvug.png)

下载官网提供的yaml格式文件，需要按照设定的尺寸进行修改
```sh
target_type: 'aprilgrid' #gridtype
tagCols: 6               #number of apriltags
tagRows: 6               #number of apriltags
tagSize: 0.022           #size of apriltag, edge to edge [m]
tagSpacing: 0.3          #ratio of space between tags to tagSize
```

找一个适合的能拍到棋盘格的距离,启动相机: `roslaunch realsense2_camera rs_camera.launch`

d453i是有红外发射器的，可以发射很多红外小斑点，如果打开你会在rviz看到很多光斑，可能不利于标定，所以标定时关闭这个发射器的。关闭发射器：在realsense-viewer里面设置后，设置的参数使用ROS Wrapper打开后依然生效，显然这是个更底层的设置，还可以用在设置滤波器等等.

将标定目标AprilGrid置于相机前方合理距离范围内，然后缓慢移动标定目标，让所有摄像头看到标定物不要太远，不然无法检测到标定目标的特征，在标定算法中需要检测是否有足够数量图片检测到标定特征，否则直接无法标定。移动标定物时候不要过快导致运动模糊，我们只需要获取不同位置和角度的图像，确保图像清晰和特征完整即可。另外要尽可能多角度和多位置（上下左右等）甚至到摄像头捕捉图像的边缘，这样移动目标1min左右即可。

##　降低图像话题的频率，录制图像数据包

kalibr在处理标定数据的时候要求图像的频率不可过高，一般为4hz(后面计算过程报错，改为20)。使用如下指令来限制图像频率:
```sh
rosrun topic_tools throttle messages /camera/color/image_raw 20 /color
rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 20 /infra_left
rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 20 /infra_right
```
用topic_tools throttle限制频率后,一定要查看限制后的topic输出频率：`rostopic hz /topic`，你会发现实际的频率与设定的频率并不一致，比如：`rosrun topic_tools throttle messages /topic_1  25  /topic_2`，如果topic_1是40hz，/topic_2可能不是25hz，而是20hz，具体原因不明。

注意这里是采用了新的话题`/color`去发布,所以下面录制要写`/color`话题

录制两分钟:
```sh
rosbag record -O multicameras_calibration /infra_left /infra_right /color
```

## kalibr算法计算各个摄像头的内参和外参

april_6x6_A4.yaml:标定物的参数，具体是标定目标的尺寸之类，因为我是缩小打印在A4上，所以要对参数进行修改；pinhole-equi – 选择的相机模型，kalibr提供了很多相机模型，可以自己选择; --bag-from-to 可以选择时间段，毕竟录制的时候不能保证整体都录制的很好。这个计算的结果会花很长时间，最后会输出一个pdf和txt文件，有内外参数据。

只标定主相机:
```sh
kalibr_calibrate_cameras --target ../yaml/april_6x6_A4.yaml --bag ./bag/0_multicameras_calibration.bag --model pinhole-equi  --topic  /color  --show-extraction --approx-sync 0.04
```
