roslaunch cartographer_ros lidar.launch
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
*******
检查全局和局部代价地图所用的参数

雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
**********
八叉树地图特点
- 稀疏: 不需要对空间进行稠密切分
- 结构化: 方块排列固定,切分为八份
- 非直接索引查询

点云地图: 无序,因为它的点都是无序的,无法坐标索引查询;
*********
近似误差：Approximation Error，指的是选择的模型并不适合当前数据所造成的误差

在每个时间点k,粒子是从提议分布中获取,以近似真实的分布,粒子被赋予权重以弥补误差.但近似误差是会随时间而增长的,也增加了粒子权重的偏差,不利于统计的准确性. 所以才有了重采样


GridSlamProcessor::scanMatch     (gridslamprocessor.hxx)

ScanMatcher::optimize             (scanmatcher.cpp)

ScanMatcher::score                (scanmatcher.h)



m_laserPose赋值在setLaserParameters,表示laser在base_link坐标系中的坐标

m_initialBeamsSkip: 开始跳过的激光束,获得激光得分时,从下标m_initialBeamsSkip的激光束开始


金坛河滨小学 0519－82837968
*******
当Neff低于N/2的时候进行重采样效果好，N为粒子数量

重采样方法就是对每个粒子i 按照其权值生成Ni个副样本

机器人的轨迹估计与真实的轨迹有一定差异，轨迹出现较大畸变的地方导致了＂假墙＂．这是粒子多样性降低造成的，需要增加粒子数．
**********
gmapping其实就是优化版的RBPF，它主要有两大优化: 1. 计算提议分布时，不仅考虑机器人的运动，而且考虑了最近的观测，使地图更精确而且减少了所需的粒子数　　2. 选择性重采样，减少粒子退化，并且只在需要时重采样

1. 时间t的粒子群{X<sub>t</sub><sup>(i)</sup>}是{X<sup>(i)</sup><sub>(t-1)</sub>}从提议分布中采样获得的，提议分布往常是里程计运动模型
2. 粒子权重w<sup>(i)</sup>是目标分布和提议分布的比，用来描述提议分布和目标分布的差别，越大说明提议分布越好
3. 重采样：只有部分粒子用于估计目标分布，重采样之后，所有粒子权重相同。如果能直接从目标分布采样，所有粒子权重都相同，实际上只用1个粒子就行，也就没有重采样的概念了。换句话说，提议分布越差，粒子群的权重差别越大，N<sub>eff</sub>就(粒子归一化权重的平方和的倒数)越大。当N<sub>eff</sub>小于粒子数一半时，执行重采样。
4. 根据轨迹各个位姿x<sup>(i)</sup><sub>1:t</sub>和各个观测Z<sub>1:t</sub>估计地图


只用里程计模型做提议分布，也就是p(x<sub>t</sub>|x<sub>t-1</sub>,u<sub>t-1</sub>)，那么粒子权重计算比较简单(公式8)，但置信区间太大，似然又太小，导致各个粒子的权重差别很大，实际上有意义的只有一小部分，所以就需要很多粒子。

相比之下，雷达观测的置信区间小，似然大，所需粒子就少了很多。提议分布变成了p(x<sub>t</sub>|m<sup>(i)</sup><sub>t-1</sub>,x<sup>(i)</sup><sub>t-1</sub>,z<sub>t</sub>,u<sub>t-1</sub>)
，粒子权重公式为公式13

因为观测似然函数的不确定形态，提议分布没有闭式解，所以方法是用采样对提议分布做估计。

1. 使用scan-matcher估计似然函数的置信区间
2. 对置信区间采样，对采样点进行评价
3. 对每个粒子计算，计算K个粒子的期望方差，计算时考虑了里程计运动信息，公式15和16


## 算法复杂度

主要影响因素是计算提议分布，更新地图，计算权重，检测是否需要重采样，重采样。  结合源码，最大的影响参数是particles, 其次是resampleThreshold, map_update_interval, 　throttle_scans, lskip

## N<sub>eff</sub>

1. 机器人经过未知区域时，N<sub>eff</sub>下降很慢
2. 机器人经过已知区域时，每个粒子都在各自的地图中保持定位，权重都相差不大
3. 当closing loop时，有些粒子能保持定位，有些则丢失了位置，权重相差很大，N<sub>eff</sub>会显著下降，执行重采样

## 缺陷

从论文和源码上看，gmapping算法有以下缺陷:
1. 观测信息比里程计估计要精确的多，而且置信区间小，似然很大．但是用户设置的`miniScore`参数过大时(超过170)，scan match失败，转而使用里程计进行位姿估计．但这样就更不准了，而且gmapping算法里没有提示
2. scan matcher计算的是观测似然函数的置信区间，但函数可能是多峰的，比如closing loop的时候，这就造成了问题，粒子群的权重会有很大波动，N<sub>eff</sub>会显著下降，当低于resampleThreshold时，就会执行重采样，然后恢复N<sub>eff</sub>最大值．N<sub>eff</sub>之所以大幅下降，就是因为观测似然出现多峰，使得提议分布与目标分布差别太大，导致粒子权重减小．
3. 遇到长走廊或很空旷的环境，雷达数据没有什么特征，比如测距都是最大值，造成位姿在走廊方向的严重不确定，此时里程计精度就很重要了，有利于粒子群的收敛。如果里程计精度不好，增加粒子数也可以解决这个问题。


综合来看，gmapping适合的环境有以下特点: 小场景、close loop比较少、没有长走廊或很空旷的环境、雷达精度高、机器人主机配置较高



for (ParticleVector::iterator it=m_particles.begin(); it!=m_particles.end(); it++)
{
    OrientedPoint& pose(it->pose);
    pose=m_motionModel.drawFromMotion(it->pose, relPose, m_odoPose);
}