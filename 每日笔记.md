roslaunch cartographer_ros lidar.launch
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
*******
检查全局和局部代价地图所用的参数

雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
**********
八叉树地图特点
- 稀疏: 不需要对空间进行稠密切分
- 结构化: 方块排列固定,切分为八份
- 非直接索引查询

点云地图: 无序,因为它的点都是无序的,无法坐标索引查询;
*********
金坛河滨小学 0519－82837968

imu的偏航角在长时间移动后会有严重的漂移误差，只能定时校准


节点`cartographer_node`的信息如下：
```sh
Publications:
 * /constraint_list [visualization_msgs/MarkerArray]
 * /landmark_poses_list [visualization_msgs/MarkerArray]
 * /scan_matched_points2 [sensor_msgs/PointCloud2]
 * /submap_list [cartographer_ros_msgs/SubmapList]
 * /trajectory_node_list [visualization_msgs/MarkerArray]

  * /tf [tf2_msgs/TFMessage]

Subscriptions:
 * /scan [sensor_msgs/LaserScan]
 * /tf [tf2_msgs/TFMessage]
 * /tf_static [tf2_msgs/TFMessage]

demo的订阅话题的不同之处：
    /horizontal_laser_2d [sensor_msgs/MultiEchoLaserScan]
    /imu [sensor_msgs/Imu]

Services:
 * /finish_trajectory
 * /start_trajectory
 * /submap_query
```

节点`cartographer_occupancy_grid_node`：
```sh
Publications:
 * /map [nav_msgs/OccupancyGrid]
 * /rosout [rosgraph_msgs/Log]

Subscriptions:
 * /submap_list [cartographer_ros_msgs/SubmapList]
```

## 保存地图

不再接受进一步数据
```sh
rosservice call /finish_trajectory 0
```

序列化保存其当前状态
```sh
rosservice call /write_state "{filename: '${HOME}/Downloads/mymap_name.pbstream'}"
```
pbstream文件包含已经保存的SLAM状态，可以在启动`cartographer_node`时加载

将pbstream转换为pgm和yaml
```sh
rosrun cartographer_ros cartographer_pbstream_to_ros_map  -map_filestem=${HOME}/Downloads/mymap_name  -pbstream_filename=${HOME}/Downloads/mymap_name.pbstream -resolution=0.05
```

用于定位时的launch
```xml
<launch>
  <arg name="load_state_filename" default="/home/xiaoqiang/Downloads/home.pbstream"/>

  <param name="robot_description"
    textfile="$(find cartographer_ros)/urdf/my_robot_2d.urdf" />

  <node name="robot_state_publisher" pkg="robot_state_publisher"
    type="robot_state_publisher" />

  <node name="cartographer_node" pkg="cartographer_ros"
      type="cartographer_node" args="
          -configuration_directory $(find cartographer_ros)/configuration_files
          -configuration_basename home_localization.lua
          -load_state_filename $(arg load_state_filename)"
      output="screen">
    <remap from="scan" to="scan" />
  </node>

  <node name="cartographer_occupancy_grid_node" pkg="cartographer_ros"
      type="cartographer_occupancy_grid_node" args="-resolution 0.05 -pure_localization 1" />
</launch>
```

使用`cartographer`建图和定位时，launch文件的不同之处在于`cartographer_node`节点的参数`-configuration_basename`和`-load_state_filename`，前者就是lua文件的不同，后者只在定位时才有，毕竟没有地图就不能定位

还有在定位时，`cartographer_occupancy_grid_node`的参数成了`args="-resolution 0.05 -pure_localization 1" />`，增加是否纯定位模式参数pure_localization

定位使用`home_localization.lua`，建图使用`home.lua`

******
Cartographer总体上可以看作是由局部地图更新和全局回环检测两个部分构成。在局部地图更新过程中，通过最优位姿估计，把激光扫描数据插入到当前维护的子图(submap)中。 由于局部地图只使用最近一段时间的传感器数据，所以存在累积误差的问题。这一问题通过全局的闭环检测来加以修正，这还是一个优化问题，Cartographer通过分支定界的方式提高了算法的运行效率。


激光雷达的扫描数据是Cartographer的主要处理对象。整个定位建图过程就是根据扫描数据，来优化机器人的位姿估计和地图占用栅格概率。 它通过两个体素滤波器输入到Local SLAM中完成局部地图的构建，生成一个个子图(Submaps)。

剩下的三个传感器数据主要是为了给寻优求解过程提供一个较好的初值，IMU数据是它们的主力。通过IMU跟踪器(IMU Tracker)和位姿推理器(PoseExtrapolator)，为Local SLAM提供初始的位姿估计。 它们的原始数据也会作用于Global SLAM中的稀疏位姿调节器(Sparse Pose Adjustment)。

里程计位姿一般是指根据移动机器人纶组上的编码器估计的机器人位姿，它是一种积分性质的位姿估计，如果机器人在运动过程中出现了打滑、碰撞等无法或者很难建模的情况时，会出现很大的误差， 而且随着时间的流逝不断累积。IMU的测量数据主要是指加表和陀螺测量的线加速度和角速度。根据惯导的理论知识，我们知道IMU是可以比较准确的估计出机器人位姿的。 但是同样会存在累积误差，系统长时间运行时如果不能及时修正就会爆炸。固定坐标系位姿(Fixed Frame Pose)，应该是指类似GPS这样具有全局定位能力的传感器数据。 这类传感器虽然能够提供全局的定位信息，但是精度和动态特性往往比较差。

Cartographer的主体则是由Local SLAM和Global SLAM两部分构成。一些资料和博客中称Local SLAM为前端，Global SLAM为后端。一般SLAM系统中的前端都只使用最近一段时间内的数据， 对算力的需求较小，可以实时计算，但存在累积误差。而后端则主要是为了解决累积误差的问题而存在的，引入了闭环检测等机制，往往是对整个地图和历史轨迹的优化，数据量和计算量上都要大很多， 但好在实时性上没有前端那么高的要求，可以在后台慢慢计算。但也不能慢的太过分，所以Cartogapher针对Global SLAM使用了分支定界的方式进行了优化一定程度上减少了算力的需求。

单线激光laser_scan，通过在配置文件中的num_laser_scans字段指定单线激光的数量。假如输入参数topics.laser_scan_topic中对应的主题名称是"scan"，那么如果只有一个单线激光，就是用scan作为订阅主题名称，如果有多个单线激光则在主题名称之后在添加添加数字予以区别，即scan_1, scan_2, ...

多线激光扫描数据(multi_echo_laser_scan)

如果是三维建图就必须使用IMU，二维建图可以通过配置文件中的use_imu_data字段设置。

"/clock"是由ROS的录包回放系统rosbag发布的主题，主要是提供一个仿真时间。 



**********
```sh
kalibr_calibrate_cameras --target /位置/文件名.yaml --bag /位置/camd435i.bag --bag-from-to 26 100 --models pinhole-radtan --topics /color --show-extraction
```
26-100指的是录制的第26秒到100秒这段时间, pinhole-radtan指的是针孔相机模型和畸变模型


使用calibration validator进行标定的验证，原理是对重投影误差进行量化分析。
`kalibr_camera_validator --cam camchain_Aprigrid.yaml --target april_6x6.yaml`

