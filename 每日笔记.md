roslaunch cartographer_ros lidar.launch
*********
```cpp
void ld_compute_cartesian(LDP ld)
{
    int i;
    for(i=0;i<ld->nrays;i++)
    {
        double x = cos(ld->theta[i]) * ld->readings[i];
        double y = sin(ld->theta[i]) * ld->readings[i];

        ld->points[i].p[0] = x, 
        ld->points[i].p[1] = y;
        ld->points[i].rho = GSL_NAN;
        ld->points[i].phi = GSL_NAN;
    }
}


void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0; i<nrays; i++)
    {
        if(!ld_valid_ray(ld,i))
            continue;
        double x0 = points[i].p[0],  y0 = points[i].p[1]; 
         // 省略: 判断x,y是否是nan
        // 算法第一步,获得帧yt的激光点在y(t-1)中的坐标
        points_w[i].p[0] = cos_theta * x0 -sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 +cos_theta*y0 + pose_y;
    }
    for(i=0;i<nrays;i++)
    {
        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
********
```cpp
for (int j = 0; j < n ; j++)
    single_ldp->theta[j] = scan[i].min_angle + j * scan[i].angle_increment;
single_ldp->min_theta = single_ldp->theta[0];
single_ldp->max_theta = single_ldp->theta[n-1];
```
std::numeric_limits <float>::quiet_NaN ();可以得到浮点型的nan
************
```cpp
// Compute laser_sens's points in laser_ref's coordinates
//ld是params的laser_sens  pose就是params的first guess,全是0
void ld_compute_world_coords(LDP ld, const double *pose)
{
    double pose_x = pose[0];
    double pose_y = pose[1];
    double pose_theta = pose[2];
    double cos_theta = cos(pose_theta); 
    double sin_theta = sin(pose_theta);
    const int nrays = ld->nrays ;

    point2d * points = ld->points;
    point2d * points_w = ld->points_w;
    int i;
    for(i=0;i<nrays;i++)
    {
        if(!ld_valid_ray(ld,i)) continue;
        double x0 = points[i].p[0], 
               y0 = points[i].p[1];
        
        points_w[i].p[0] = cos_theta * x0 - sin_theta*y0 + pose_x;
        points_w[i].p[1] = sin_theta * x0 + cos_theta*y0 + pose_y;

        double x = points_w[i].p[0];
        double y = points_w[i].p[1];
        points_w[i].rho = sqrt( x*x+y*y);
        points_w[i].phi = atan2(y, x);
    }
}
```
*******
检查全局和局部代价地图所用的参数

雷达深度传感器，基于极坐标，可以持续的读取各个离散角度方向的深度。所谓地图配准问题，就是根据机器人的传感器测量数值来计算机器人的位姿，以此最好的适配地图。
*********************
机器人移动时，机器人位置在变化，激光雷达的位置也在变化，所以每一帧的雷达数据的坐标系都不同，需要将它们统一到同一个坐标系下。雷达数据的特征提取和匹配是机器人的初定位。
**********
八叉树地图特点
- 稀疏: 不需要对空间进行稠密切分
- 结构化: 方块排列固定,切分为八份
- 非直接索引查询

点云地图: 无序,因为它的点都是无序的,无法坐标索引查询;
*********
金坛河滨小学 0519－82837968

imu的偏航角在长时间移动后会有严重的漂移误差，只能定时校准


节点`cartographer_node`的信息如下：
```sh
Publications:
 * /constraint_list [visualization_msgs/MarkerArray]
 * /landmark_poses_list [visualization_msgs/MarkerArray]
 * /scan_matched_points2 [sensor_msgs/PointCloud2]
 * /submap_list [cartographer_ros_msgs/SubmapList]
 * /trajectory_node_list [visualization_msgs/MarkerArray]

  * /tf [tf2_msgs/TFMessage]

Subscriptions:
 * /scan [sensor_msgs/LaserScan]
 * /tf [tf2_msgs/TFMessage]
 * /tf_static [tf2_msgs/TFMessage]

demo的订阅话题的不同之处：
    /horizontal_laser_2d [sensor_msgs/MultiEchoLaserScan]
    /imu [sensor_msgs/Imu]

Services:
 * /finish_trajectory
 * /start_trajectory
 * /submap_query
```

节点`cartographer_occupancy_grid_node`：
```sh
Publications:
 * /map [nav_msgs/OccupancyGrid]
 * /rosout [rosgraph_msgs/Log]

Subscriptions:
 * /submap_list [cartographer_ros_msgs/SubmapList]
```
***********
cartographer的安装非常复杂，尤其是proto脚本和各种依赖项，如果一次不成功，最好把proto或其他依赖库彻底删除重来，越改可能越乱，再也装不好了。

先看options的内容，这是通用的参数。开头的`map_builder = MAP_BUILDER`和`trajectory_builder = TRAJECTORY_BUILDER`万年不变

### 坐标系组

- map_frame: 用于发布submaps的ROS坐标系，也是位姿的父坐标系，通常是map

- tracking_frame: SLAM算法追踪的ROS坐标系，如果使用IMU，就是"imu_link";如果不用IMU，可以用"laser"

- published_frame: 位姿子坐标系的ROS坐标系，例如"odom"坐标系，如果一个odom坐标系由系统的不同部分提供，在这种情况下，map_frame中的“odom”姿势将被发布。 否则，将其设置为“base_link”可能是合适的

- provide_odom_frame: 如果启用，将发布局部、非闭环、持续的位姿，也就是odom_frame在map_frame中的坐标
- odom_frame: 在provide_odom_frame为真才启用，坐标系在published_frame和map_frame之间用于发布局部SLAM结果，通常是"odom"
- use_odometry: 如果启用，会订阅关于odom话题(或者叫其他名字)的`nav_msgs/Odometry`消息。应当提供里程信息，这些信息包含在SLAM里

- use_nav_sat: 如果启用，将订阅`sensor_msgs/NavSatFix`的话题，比如fix. 应当提供导航数据，将用于全局SLAM
- use_landmarks: 如果启用，订阅`cartographer_ros_msgs/LandmarkList`的话题，比如landmarks. 应当提供Landmarks信息，这些信息包含在SLAM里

### num组

`Cartographer`可以订阅的主题有三种，我们一般用`scan`，还可以用`echoes`或`points2`，这三个是互斥的。分别对应lua中的`num_laser_scans`, `num_multi_echo_laser_scans`,`num_point_clouds`. 

lua中将`num_laser_scans`设置为1，则`scan`将用作SLAM的输入，如果`num_laser_scans`大于1，则多个编号的扫描主题（即scan_1，scan_2，scan_3，......直到并包括num_laser_scans）将用作SLAM的输入.

同理，如果将`num_multi_echo_laser_scans`设置为１，则`echoes`做输入，但仅使用第一个回声，如果大于1，则多个编号的回声主题（即echoes_1，echoes_2，echoes_3，......直到并包括num_multi_echo_laser_scans）将用作SLAM的输入。`echoes`的消息类型为`sensor_msgs/MultiEchoLaserScan`，不同之处在于`sensor_msgs/LaserEcho[] ranges`和`sensor_msgs/LaserEcho[] intensities`

首先需要雷达支持多echo，每个脉冲发出以后，会有多个echo返回。我们知道一般雷达要避免扫描玻璃，因为laser会穿透过去，但多echo雷达不仅可以获得玻璃返回的echo,也能获得玻璃后面的墙返回的echo，这样我们就获得不同深度的信息，对建图定位的帮助更大。

`points２`也是这样，消息类型`sensor_msgs/PointCloud2`


- num_subdivisions_per_laser_scan:将每个接收到的激光(或echoes)扫描分成的点云数,默认10。调用在`HandleLaserScan`函数中, 对点云points细分，points的类型为`cartographer_ros`自定义类型，保存了每个点的光强、位置与时间增量

### period组

- lookup_transform_timeout_sec: 使用tf2查找变换的超时秒数
- submap_publish_period_sec: 发布submap的间隔
- pose_publish_period_sec: 发布姿势的间隔，例如5e-3，频率为200Hz
- trajectory_publish_period_sec: 发布轨迹标记的时间间隔

### ratio组

- rangefinder_sampling_ratio: Fixed ratio sampling for range finders messages.
- odometry_sampling_ratio: Fixed ratio sampling for odometry messages.
- fixed_frame_sampling_ratio: Fixed ratio sampling for fixed frame messages.
- imu_sampling_ratio: Fixed ratio sampling for IMU messages.
- landmarks_sampling_ratio: Fixed ratio sampling for landmarks messages.

**********
之前听说了启晗考试又考的不好,心里也很着急,她自制能力差,又不注重学习方法,最关键的是早期智力没有得到开发，现在就没达到一个初中生的智力水平。你们都不注重孩子的智力开发，不让看一些有意义的书和电视，总是离不了学校那几本书，光看那几本书，最后只能变成傻子。以前给她买的一些有意义的书，估计也没有认真看。之前给她买一本名著小说，过了不到一天就说看完了，这能看个什么。以前总是放纵她看一些弱智的动画片，优优看什么，她也看什么，这怎么就提高智力了。她干不了的事也不去教，光知道替她干，以后她还是不会，这换了谁也不能成长。这么大了还要人接送，光知道把她当成孩子看，就是不让孩子有独立生活能力。直到现在，她吃饭还是慢，几年前我就觉得她吃饭慢，现在还是改善不了，明显就是你们不会教育，换了我的孩子，到时间吃不完就算了，饿几顿马上就吃快了。吃饭是慢，做题也是慢，总不能到了二十多岁做事情还这么慢。腿摔伤后在家那么长时间就不能改善这个问题，你们就是不严格管教，真是让人失望。

看看咱们县的教育，才有几个上学像样的，随便接触一个，连本科都没上过，好多都考不上高中。你就是不愿意承认，越是贫困落后的地方，越出不了优秀的人，一上赞中就考不了好大学，这几乎都成规律了。直到现在我都后悔遇到孙立军这个人，要不是他，我也不至于奋斗这么艰难，至今我也没有咽下这口气。从他开始，我是打死也不相信赞皇能出优秀人才。当初眼看着前途都要毁在他手里，气的天天着急，最后有了着急就头痛的毛病，就因为他，起点比我低，不如我的人现在都比我强了，这口气一直出不来，想起他就想破口大骂。
 